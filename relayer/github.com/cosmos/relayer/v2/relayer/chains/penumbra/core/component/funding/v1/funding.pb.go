// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/funding/v1/funding.proto

package fundingv1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1"
	v17 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/dex/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1"
	v16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1"
	v15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/txhash/v1"
	v13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_rdsa/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Request if a nullifier is already used in a specific epoch.
type LqtCheckNullifierRequest struct {
	// The epoch index in which to check for nullifier usage.
	EpochIndex uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The nullifier whose voting status is being queried.
	Nullifier *v1.Nullifier `protobuf:"bytes,2,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
}

func (m *LqtCheckNullifierRequest) Reset()         { *m = LqtCheckNullifierRequest{} }
func (m *LqtCheckNullifierRequest) String() string { return proto.CompactTextString(m) }
func (*LqtCheckNullifierRequest) ProtoMessage()    {}
func (*LqtCheckNullifierRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{0}
}
func (m *LqtCheckNullifierRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LqtCheckNullifierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LqtCheckNullifierRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LqtCheckNullifierRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LqtCheckNullifierRequest.Merge(m, src)
}
func (m *LqtCheckNullifierRequest) XXX_Size() int {
	return m.Size()
}
func (m *LqtCheckNullifierRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LqtCheckNullifierRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LqtCheckNullifierRequest proto.InternalMessageInfo

func (m *LqtCheckNullifierRequest) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *LqtCheckNullifierRequest) GetNullifier() *v1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

// Response indicating whether the nullifier was already used.
type LqtCheckNullifierResponse struct {
	// The transaction ID of the vote, if the nullifier has been used.
	// This field is always present if `already_voted` is true.
	Transaction *v11.TransactionId `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	// Indicates whether the nullifier has already been used for voting in the given epoch.
	AlreadyVoted bool `protobuf:"varint,2,opt,name=already_voted,json=alreadyVoted,proto3" json:"already_voted,omitempty"`
	// The epoch index in which the nullifier was checked.
	EpochIndex uint64 `protobuf:"varint,3,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
}

func (m *LqtCheckNullifierResponse) Reset()         { *m = LqtCheckNullifierResponse{} }
func (m *LqtCheckNullifierResponse) String() string { return proto.CompactTextString(m) }
func (*LqtCheckNullifierResponse) ProtoMessage()    {}
func (*LqtCheckNullifierResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{1}
}
func (m *LqtCheckNullifierResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LqtCheckNullifierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LqtCheckNullifierResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LqtCheckNullifierResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LqtCheckNullifierResponse.Merge(m, src)
}
func (m *LqtCheckNullifierResponse) XXX_Size() int {
	return m.Size()
}
func (m *LqtCheckNullifierResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LqtCheckNullifierResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LqtCheckNullifierResponse proto.InternalMessageInfo

func (m *LqtCheckNullifierResponse) GetTransaction() *v11.TransactionId {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *LqtCheckNullifierResponse) GetAlreadyVoted() bool {
	if m != nil {
		return m.AlreadyVoted
	}
	return false
}

func (m *LqtCheckNullifierResponse) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

// Funding component configuration data.
type FundingParameters struct {
	// The parameters governing the funding of the liquidity tournament.
	LiquidityTournament *FundingParameters_LiquidityTournament `protobuf:"bytes,1,opt,name=liquidity_tournament,json=liquidityTournament,proto3" json:"liquidity_tournament,omitempty"`
}

func (m *FundingParameters) Reset()         { *m = FundingParameters{} }
func (m *FundingParameters) String() string { return proto.CompactTextString(m) }
func (*FundingParameters) ProtoMessage()    {}
func (*FundingParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{2}
}
func (m *FundingParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingParameters.Merge(m, src)
}
func (m *FundingParameters) XXX_Size() int {
	return m.Size()
}
func (m *FundingParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingParameters.DiscardUnknown(m)
}

var xxx_messageInfo_FundingParameters proto.InternalMessageInfo

func (m *FundingParameters) GetLiquidityTournament() *FundingParameters_LiquidityTournament {
	if m != nil {
		return m.LiquidityTournament
	}
	return nil
}

type FundingParameters_LiquidityTournament struct {
	// The fraction of gauge votes that an asset must pass to get any rewards.
	//
	// Takes a value in [0, 100].
	GaugeThresholdPercent uint64 `protobuf:"varint,1,opt,name=gauge_threshold_percent,json=gaugeThresholdPercent,proto3" json:"gauge_threshold_percent,omitempty"`
	// The maximum number of liquidity positions that can receive rewards.
	//
	// This avoids potential DoS vectors with processing a large number of small positions.
	MaxPositions uint64 `protobuf:"varint,2,opt,name=max_positions,json=maxPositions,proto3" json:"max_positions,omitempty"`
	// The maximum number of delegators that can be rewarded.
	//
	// Also avoids potential DoS vectors
	MaxDelegators uint64 `protobuf:"varint,3,opt,name=max_delegators,json=maxDelegators,proto3" json:"max_delegators,omitempty"`
	// The share of rewards which will go to delegators, opposed with positions.
	//
	// Takes a value in [0, 100].
	DelegatorSharePercent uint64 `protobuf:"varint,4,opt,name=delegator_share_percent,json=delegatorSharePercent,proto3" json:"delegator_share_percent,omitempty"`
}

func (m *FundingParameters_LiquidityTournament) Reset()         { *m = FundingParameters_LiquidityTournament{} }
func (m *FundingParameters_LiquidityTournament) String() string { return proto.CompactTextString(m) }
func (*FundingParameters_LiquidityTournament) ProtoMessage()    {}
func (*FundingParameters_LiquidityTournament) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{2, 0}
}
func (m *FundingParameters_LiquidityTournament) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingParameters_LiquidityTournament) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingParameters_LiquidityTournament.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingParameters_LiquidityTournament) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingParameters_LiquidityTournament.Merge(m, src)
}
func (m *FundingParameters_LiquidityTournament) XXX_Size() int {
	return m.Size()
}
func (m *FundingParameters_LiquidityTournament) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingParameters_LiquidityTournament.DiscardUnknown(m)
}

var xxx_messageInfo_FundingParameters_LiquidityTournament proto.InternalMessageInfo

func (m *FundingParameters_LiquidityTournament) GetGaugeThresholdPercent() uint64 {
	if m != nil {
		return m.GaugeThresholdPercent
	}
	return 0
}

func (m *FundingParameters_LiquidityTournament) GetMaxPositions() uint64 {
	if m != nil {
		return m.MaxPositions
	}
	return 0
}

func (m *FundingParameters_LiquidityTournament) GetMaxDelegators() uint64 {
	if m != nil {
		return m.MaxDelegators
	}
	return 0
}

func (m *FundingParameters_LiquidityTournament) GetDelegatorSharePercent() uint64 {
	if m != nil {
		return m.DelegatorSharePercent
	}
	return 0
}

// Genesis data for the funding component.
type GenesisContent struct {
	FundingParams *FundingParameters `protobuf:"bytes,1,opt,name=funding_params,json=fundingParams,proto3" json:"funding_params,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{3}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetFundingParams() *FundingParameters {
	if m != nil {
		return m.FundingParams
	}
	return nil
}

// Indicates that a funding stream reward was paid.
type EventFundingStreamReward struct {
	// The recipient of the funding stream reward.
	// This is a string value for future extensibility.
	// Currently it will be either "community-pool"
	// or an address.
	Recipient string `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// The epoch for which the reward was paid.
	EpochIndex uint64 `protobuf:"varint,2,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The amount of the reward, in staking tokens.
	RewardAmount *v12.Amount `protobuf:"bytes,3,opt,name=reward_amount,json=rewardAmount,proto3" json:"reward_amount,omitempty"`
}

func (m *EventFundingStreamReward) Reset()         { *m = EventFundingStreamReward{} }
func (m *EventFundingStreamReward) String() string { return proto.CompactTextString(m) }
func (*EventFundingStreamReward) ProtoMessage()    {}
func (*EventFundingStreamReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{4}
}
func (m *EventFundingStreamReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFundingStreamReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFundingStreamReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFundingStreamReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFundingStreamReward.Merge(m, src)
}
func (m *EventFundingStreamReward) XXX_Size() int {
	return m.Size()
}
func (m *EventFundingStreamReward) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFundingStreamReward.DiscardUnknown(m)
}

var xxx_messageInfo_EventFundingStreamReward proto.InternalMessageInfo

func (m *EventFundingStreamReward) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *EventFundingStreamReward) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *EventFundingStreamReward) GetRewardAmount() *v12.Amount {
	if m != nil {
		return m.RewardAmount
	}
	return nil
}

// An action for voting in a liquidity tournament.
type ActionLiquidityTournamentVote struct {
	// The effectful data signalling user intent, and the validity of this intent.
	Body *LiquidityTournamentVoteBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// An authorization from the user over this body.
	AuthSig *v13.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// A ZK proof that it was correctly constructed from private user state.
	Proof *ZKLiquidityTournamentVoteProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *ActionLiquidityTournamentVote) Reset()         { *m = ActionLiquidityTournamentVote{} }
func (m *ActionLiquidityTournamentVote) String() string { return proto.CompactTextString(m) }
func (*ActionLiquidityTournamentVote) ProtoMessage()    {}
func (*ActionLiquidityTournamentVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{5}
}
func (m *ActionLiquidityTournamentVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLiquidityTournamentVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLiquidityTournamentVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLiquidityTournamentVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLiquidityTournamentVote.Merge(m, src)
}
func (m *ActionLiquidityTournamentVote) XXX_Size() int {
	return m.Size()
}
func (m *ActionLiquidityTournamentVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLiquidityTournamentVote.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLiquidityTournamentVote proto.InternalMessageInfo

func (m *ActionLiquidityTournamentVote) GetBody() *LiquidityTournamentVoteBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ActionLiquidityTournamentVote) GetAuthSig() *v13.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *ActionLiquidityTournamentVote) GetProof() *ZKLiquidityTournamentVoteProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type LiquidityTournamentVoteBody struct {
	// Which asset should be incentivized.
	Incentivized *v14.Denom `protobuf:"bytes,1,opt,name=incentivized,proto3" json:"incentivized,omitempty"`
	// Where to send any rewards for participating in the tournament.
	RewardsRecipient *v15.Address `protobuf:"bytes,2,opt,name=rewards_recipient,json=rewardsRecipient,proto3" json:"rewards_recipient,omitempty"`
	// The start position of the tournament
	StartPosition uint64 `protobuf:"varint,3,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The value being voted with.
	//
	// This should be some amount of a validator's delegation token.
	Value *v14.Value `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// The nullifier associated with the note being spent.
	Nullifier *v1.Nullifier `protobuf:"bytes,5,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// A randomized verification key with which to check the auth signature.
	Rk *v13.SpendVerificationKey `protobuf:"bytes,6,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *LiquidityTournamentVoteBody) Reset()         { *m = LiquidityTournamentVoteBody{} }
func (m *LiquidityTournamentVoteBody) String() string { return proto.CompactTextString(m) }
func (*LiquidityTournamentVoteBody) ProtoMessage()    {}
func (*LiquidityTournamentVoteBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{6}
}
func (m *LiquidityTournamentVoteBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTournamentVoteBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTournamentVoteBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTournamentVoteBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTournamentVoteBody.Merge(m, src)
}
func (m *LiquidityTournamentVoteBody) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTournamentVoteBody) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTournamentVoteBody.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTournamentVoteBody proto.InternalMessageInfo

func (m *LiquidityTournamentVoteBody) GetIncentivized() *v14.Denom {
	if m != nil {
		return m.Incentivized
	}
	return nil
}

func (m *LiquidityTournamentVoteBody) GetRewardsRecipient() *v15.Address {
	if m != nil {
		return m.RewardsRecipient
	}
	return nil
}

func (m *LiquidityTournamentVoteBody) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *LiquidityTournamentVoteBody) GetValue() *v14.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *LiquidityTournamentVoteBody) GetNullifier() *v1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *LiquidityTournamentVoteBody) GetRk() *v13.SpendVerificationKey {
	if m != nil {
		return m.Rk
	}
	return nil
}

// The plan associated with a `ActionLiquidityTournamentVote`.
type ActionLiquidityTournamentVotePlan struct {
	// The asset the user wants to vote for.
	Incentivized *v14.Denom `protobuf:"bytes,1,opt,name=incentivized,proto3" json:"incentivized,omitempty"`
	// Where to send any rewards for participating in the tournament.
	RewardsRecipient *v15.Address `protobuf:"bytes,2,opt,name=rewards_recipient,json=rewardsRecipient,proto3" json:"rewards_recipient,omitempty"`
	// The note containing the staked note used for voting.
	StakedNote *v16.Note `protobuf:"bytes,3,opt,name=staked_note,json=stakedNote,proto3" json:"staked_note,omitempty"`
	// The position of the staked note.
	StakedNotePosition uint64 `protobuf:"varint,4,opt,name=staked_note_position,json=stakedNotePosition,proto3" json:"staked_note_position,omitempty"`
	// The start position of the tournament.
	StartPosition uint64 `protobuf:"varint,5,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// Randomizer for proof of spend capability.
	Randomizer     []byte `protobuf:"bytes,6,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	ProofBlindingR []byte `protobuf:"bytes,7,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	ProofBlindingS []byte `protobuf:"bytes,8,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *ActionLiquidityTournamentVotePlan) Reset()         { *m = ActionLiquidityTournamentVotePlan{} }
func (m *ActionLiquidityTournamentVotePlan) String() string { return proto.CompactTextString(m) }
func (*ActionLiquidityTournamentVotePlan) ProtoMessage()    {}
func (*ActionLiquidityTournamentVotePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{7}
}
func (m *ActionLiquidityTournamentVotePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLiquidityTournamentVotePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLiquidityTournamentVotePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLiquidityTournamentVotePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLiquidityTournamentVotePlan.Merge(m, src)
}
func (m *ActionLiquidityTournamentVotePlan) XXX_Size() int {
	return m.Size()
}
func (m *ActionLiquidityTournamentVotePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLiquidityTournamentVotePlan.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLiquidityTournamentVotePlan proto.InternalMessageInfo

func (m *ActionLiquidityTournamentVotePlan) GetIncentivized() *v14.Denom {
	if m != nil {
		return m.Incentivized
	}
	return nil
}

func (m *ActionLiquidityTournamentVotePlan) GetRewardsRecipient() *v15.Address {
	if m != nil {
		return m.RewardsRecipient
	}
	return nil
}

func (m *ActionLiquidityTournamentVotePlan) GetStakedNote() *v16.Note {
	if m != nil {
		return m.StakedNote
	}
	return nil
}

func (m *ActionLiquidityTournamentVotePlan) GetStakedNotePosition() uint64 {
	if m != nil {
		return m.StakedNotePosition
	}
	return 0
}

func (m *ActionLiquidityTournamentVotePlan) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *ActionLiquidityTournamentVotePlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *ActionLiquidityTournamentVotePlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *ActionLiquidityTournamentVotePlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// A proof of the validity of a liquidity vote, wrt private state.
type ZKLiquidityTournamentVoteProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKLiquidityTournamentVoteProof) Reset()         { *m = ZKLiquidityTournamentVoteProof{} }
func (m *ZKLiquidityTournamentVoteProof) String() string { return proto.CompactTextString(m) }
func (*ZKLiquidityTournamentVoteProof) ProtoMessage()    {}
func (*ZKLiquidityTournamentVoteProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{8}
}
func (m *ZKLiquidityTournamentVoteProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKLiquidityTournamentVoteProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKLiquidityTournamentVoteProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKLiquidityTournamentVoteProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKLiquidityTournamentVoteProof.Merge(m, src)
}
func (m *ZKLiquidityTournamentVoteProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKLiquidityTournamentVoteProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKLiquidityTournamentVoteProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKLiquidityTournamentVoteProof proto.InternalMessageInfo

func (m *ZKLiquidityTournamentVoteProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

type ActionLiquidityTournamentVoteView struct {
	// Types that are valid to be assigned to LiquidityTournamentVote:
	//	*ActionLiquidityTournamentVoteView_Visible_
	//	*ActionLiquidityTournamentVoteView_Opaque_
	LiquidityTournamentVote isActionLiquidityTournamentVoteView_LiquidityTournamentVote `protobuf_oneof:"liquidity_tournament_vote"`
}

func (m *ActionLiquidityTournamentVoteView) Reset()         { *m = ActionLiquidityTournamentVoteView{} }
func (m *ActionLiquidityTournamentVoteView) String() string { return proto.CompactTextString(m) }
func (*ActionLiquidityTournamentVoteView) ProtoMessage()    {}
func (*ActionLiquidityTournamentVoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{9}
}
func (m *ActionLiquidityTournamentVoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLiquidityTournamentVoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLiquidityTournamentVoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLiquidityTournamentVoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLiquidityTournamentVoteView.Merge(m, src)
}
func (m *ActionLiquidityTournamentVoteView) XXX_Size() int {
	return m.Size()
}
func (m *ActionLiquidityTournamentVoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLiquidityTournamentVoteView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLiquidityTournamentVoteView proto.InternalMessageInfo

type isActionLiquidityTournamentVoteView_LiquidityTournamentVote interface {
	isActionLiquidityTournamentVoteView_LiquidityTournamentVote()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionLiquidityTournamentVoteView_Visible_ struct {
	Visible *ActionLiquidityTournamentVoteView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type ActionLiquidityTournamentVoteView_Opaque_ struct {
	Opaque *ActionLiquidityTournamentVoteView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*ActionLiquidityTournamentVoteView_Visible_) isActionLiquidityTournamentVoteView_LiquidityTournamentVote() {
}
func (*ActionLiquidityTournamentVoteView_Opaque_) isActionLiquidityTournamentVoteView_LiquidityTournamentVote() {
}

func (m *ActionLiquidityTournamentVoteView) GetLiquidityTournamentVote() isActionLiquidityTournamentVoteView_LiquidityTournamentVote {
	if m != nil {
		return m.LiquidityTournamentVote
	}
	return nil
}

func (m *ActionLiquidityTournamentVoteView) GetVisible() *ActionLiquidityTournamentVoteView_Visible {
	if x, ok := m.GetLiquidityTournamentVote().(*ActionLiquidityTournamentVoteView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *ActionLiquidityTournamentVoteView) GetOpaque() *ActionLiquidityTournamentVoteView_Opaque {
	if x, ok := m.GetLiquidityTournamentVote().(*ActionLiquidityTournamentVoteView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionLiquidityTournamentVoteView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionLiquidityTournamentVoteView_Visible_)(nil),
		(*ActionLiquidityTournamentVoteView_Opaque_)(nil),
	}
}

// If we initiated the vote, we should know the note that we spent.
type ActionLiquidityTournamentVoteView_Visible struct {
	Vote *ActionLiquidityTournamentVote `protobuf:"bytes,1,opt,name=vote,proto3" json:"vote,omitempty"`
	Note *v16.NoteView                  `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *ActionLiquidityTournamentVoteView_Visible) Reset() {
	*m = ActionLiquidityTournamentVoteView_Visible{}
}
func (m *ActionLiquidityTournamentVoteView_Visible) String() string {
	return proto.CompactTextString(m)
}
func (*ActionLiquidityTournamentVoteView_Visible) ProtoMessage() {}
func (*ActionLiquidityTournamentVoteView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{9, 0}
}
func (m *ActionLiquidityTournamentVoteView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLiquidityTournamentVoteView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLiquidityTournamentVoteView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLiquidityTournamentVoteView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLiquidityTournamentVoteView_Visible.Merge(m, src)
}
func (m *ActionLiquidityTournamentVoteView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *ActionLiquidityTournamentVoteView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLiquidityTournamentVoteView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLiquidityTournamentVoteView_Visible proto.InternalMessageInfo

func (m *ActionLiquidityTournamentVoteView_Visible) GetVote() *ActionLiquidityTournamentVote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *ActionLiquidityTournamentVoteView_Visible) GetNote() *v16.NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type ActionLiquidityTournamentVoteView_Opaque struct {
	Vote *ActionLiquidityTournamentVote `protobuf:"bytes,1,opt,name=vote,proto3" json:"vote,omitempty"`
}

func (m *ActionLiquidityTournamentVoteView_Opaque) Reset() {
	*m = ActionLiquidityTournamentVoteView_Opaque{}
}
func (m *ActionLiquidityTournamentVoteView_Opaque) String() string { return proto.CompactTextString(m) }
func (*ActionLiquidityTournamentVoteView_Opaque) ProtoMessage()    {}
func (*ActionLiquidityTournamentVoteView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{9, 1}
}
func (m *ActionLiquidityTournamentVoteView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLiquidityTournamentVoteView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLiquidityTournamentVoteView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLiquidityTournamentVoteView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLiquidityTournamentVoteView_Opaque.Merge(m, src)
}
func (m *ActionLiquidityTournamentVoteView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *ActionLiquidityTournamentVoteView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLiquidityTournamentVoteView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLiquidityTournamentVoteView_Opaque proto.InternalMessageInfo

func (m *ActionLiquidityTournamentVoteView_Opaque) GetVote() *ActionLiquidityTournamentVote {
	if m != nil {
		return m.Vote
	}
	return nil
}

type EventLqtDelegatorReward struct {
	// The epoch for which the reward was paid.
	EpochIndex uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The amount of reward, in staking tokens.
	RewardAmount *v12.Amount `protobuf:"bytes,2,opt,name=reward_amount,json=rewardAmount,proto3" json:"reward_amount,omitempty"`
	// The amount of reward, in delegation tokens.
	DelegationTokens *v14.Value `protobuf:"bytes,3,opt,name=delegation_tokens,json=delegationTokens,proto3" json:"delegation_tokens,omitempty"`
	// The recipient of the reward
	Address *v15.Address `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	// The incentivized asset.
	IncentivizedAssetId *v14.AssetId `protobuf:"bytes,5,opt,name=incentivized_asset_id,json=incentivizedAssetId,proto3" json:"incentivized_asset_id,omitempty"`
}

func (m *EventLqtDelegatorReward) Reset()         { *m = EventLqtDelegatorReward{} }
func (m *EventLqtDelegatorReward) String() string { return proto.CompactTextString(m) }
func (*EventLqtDelegatorReward) ProtoMessage()    {}
func (*EventLqtDelegatorReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{10}
}
func (m *EventLqtDelegatorReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLqtDelegatorReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLqtDelegatorReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLqtDelegatorReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLqtDelegatorReward.Merge(m, src)
}
func (m *EventLqtDelegatorReward) XXX_Size() int {
	return m.Size()
}
func (m *EventLqtDelegatorReward) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLqtDelegatorReward.DiscardUnknown(m)
}

var xxx_messageInfo_EventLqtDelegatorReward proto.InternalMessageInfo

func (m *EventLqtDelegatorReward) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *EventLqtDelegatorReward) GetRewardAmount() *v12.Amount {
	if m != nil {
		return m.RewardAmount
	}
	return nil
}

func (m *EventLqtDelegatorReward) GetDelegationTokens() *v14.Value {
	if m != nil {
		return m.DelegationTokens
	}
	return nil
}

func (m *EventLqtDelegatorReward) GetAddress() *v15.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *EventLqtDelegatorReward) GetIncentivizedAssetId() *v14.AssetId {
	if m != nil {
		return m.IncentivizedAssetId
	}
	return nil
}

type EventLqtPositionReward struct {
	// The epoch for which the reward was paid.
	EpochIndex uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The amount of the reward, in staking tokens.
	RewardAmount *v12.Amount `protobuf:"bytes,2,opt,name=reward_amount,json=rewardAmount,proto3" json:"reward_amount,omitempty"`
	// The liquidity position receiving the reward
	PositionId *v17.PositionId `protobuf:"bytes,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// The incentivized asset.
	IncentivizedAssetId *v14.AssetId `protobuf:"bytes,4,opt,name=incentivized_asset_id,json=incentivizedAssetId,proto3" json:"incentivized_asset_id,omitempty"`
	// The total volume for the pair during the tournament, in staking tokens.
	TournamentVolume *v12.Amount `protobuf:"bytes,10,opt,name=tournament_volume,json=tournamentVolume,proto3" json:"tournament_volume,omitempty"`
	// The cumulative volume for the LP, in staking tokens.
	PositionVolume *v12.Amount `protobuf:"bytes,11,opt,name=position_volume,json=positionVolume,proto3" json:"position_volume,omitempty"`
}

func (m *EventLqtPositionReward) Reset()         { *m = EventLqtPositionReward{} }
func (m *EventLqtPositionReward) String() string { return proto.CompactTextString(m) }
func (*EventLqtPositionReward) ProtoMessage()    {}
func (*EventLqtPositionReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{11}
}
func (m *EventLqtPositionReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLqtPositionReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLqtPositionReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLqtPositionReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLqtPositionReward.Merge(m, src)
}
func (m *EventLqtPositionReward) XXX_Size() int {
	return m.Size()
}
func (m *EventLqtPositionReward) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLqtPositionReward.DiscardUnknown(m)
}

var xxx_messageInfo_EventLqtPositionReward proto.InternalMessageInfo

func (m *EventLqtPositionReward) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *EventLqtPositionReward) GetRewardAmount() *v12.Amount {
	if m != nil {
		return m.RewardAmount
	}
	return nil
}

func (m *EventLqtPositionReward) GetPositionId() *v17.PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *EventLqtPositionReward) GetIncentivizedAssetId() *v14.AssetId {
	if m != nil {
		return m.IncentivizedAssetId
	}
	return nil
}

func (m *EventLqtPositionReward) GetTournamentVolume() *v12.Amount {
	if m != nil {
		return m.TournamentVolume
	}
	return nil
}

func (m *EventLqtPositionReward) GetPositionVolume() *v12.Amount {
	if m != nil {
		return m.PositionVolume
	}
	return nil
}

type EventLqtVote struct {
	// The tournament for which the vote was cast.
	EpochIndex uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The amount of voting power this vote carries.
	VotingPower *v12.Amount `protobuf:"bytes,2,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	// The asset id of the asset being voted on.
	IncentivizedAssetId *v14.AssetId `protobuf:"bytes,3,opt,name=incentivized_asset_id,json=incentivizedAssetId,proto3" json:"incentivized_asset_id,omitempty"`
	// The denom string of the asset being voted on.
	Incentivized *v14.Denom `protobuf:"bytes,4,opt,name=incentivized,proto3" json:"incentivized,omitempty"`
	// The beneficiary of the rewards this vote might receive.
	RewardsRecipient *v15.Address `protobuf:"bytes,5,opt,name=rewards_recipient,json=rewardsRecipient,proto3" json:"rewards_recipient,omitempty"`
	// The transaction ID of the vote.
	TxId *v11.TransactionId `protobuf:"bytes,6,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (m *EventLqtVote) Reset()         { *m = EventLqtVote{} }
func (m *EventLqtVote) String() string { return proto.CompactTextString(m) }
func (*EventLqtVote) ProtoMessage()    {}
func (*EventLqtVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_586f7399b4e8a469, []int{12}
}
func (m *EventLqtVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLqtVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLqtVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLqtVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLqtVote.Merge(m, src)
}
func (m *EventLqtVote) XXX_Size() int {
	return m.Size()
}
func (m *EventLqtVote) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLqtVote.DiscardUnknown(m)
}

var xxx_messageInfo_EventLqtVote proto.InternalMessageInfo

func (m *EventLqtVote) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *EventLqtVote) GetVotingPower() *v12.Amount {
	if m != nil {
		return m.VotingPower
	}
	return nil
}

func (m *EventLqtVote) GetIncentivizedAssetId() *v14.AssetId {
	if m != nil {
		return m.IncentivizedAssetId
	}
	return nil
}

func (m *EventLqtVote) GetIncentivized() *v14.Denom {
	if m != nil {
		return m.Incentivized
	}
	return nil
}

func (m *EventLqtVote) GetRewardsRecipient() *v15.Address {
	if m != nil {
		return m.RewardsRecipient
	}
	return nil
}

func (m *EventLqtVote) GetTxId() *v11.TransactionId {
	if m != nil {
		return m.TxId
	}
	return nil
}

func init() {
	proto.RegisterType((*LqtCheckNullifierRequest)(nil), "penumbra.core.component.funding.v1.LqtCheckNullifierRequest")
	proto.RegisterType((*LqtCheckNullifierResponse)(nil), "penumbra.core.component.funding.v1.LqtCheckNullifierResponse")
	proto.RegisterType((*FundingParameters)(nil), "penumbra.core.component.funding.v1.FundingParameters")
	proto.RegisterType((*FundingParameters_LiquidityTournament)(nil), "penumbra.core.component.funding.v1.FundingParameters.LiquidityTournament")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.funding.v1.GenesisContent")
	proto.RegisterType((*EventFundingStreamReward)(nil), "penumbra.core.component.funding.v1.EventFundingStreamReward")
	proto.RegisterType((*ActionLiquidityTournamentVote)(nil), "penumbra.core.component.funding.v1.ActionLiquidityTournamentVote")
	proto.RegisterType((*LiquidityTournamentVoteBody)(nil), "penumbra.core.component.funding.v1.LiquidityTournamentVoteBody")
	proto.RegisterType((*ActionLiquidityTournamentVotePlan)(nil), "penumbra.core.component.funding.v1.ActionLiquidityTournamentVotePlan")
	proto.RegisterType((*ZKLiquidityTournamentVoteProof)(nil), "penumbra.core.component.funding.v1.ZKLiquidityTournamentVoteProof")
	proto.RegisterType((*ActionLiquidityTournamentVoteView)(nil), "penumbra.core.component.funding.v1.ActionLiquidityTournamentVoteView")
	proto.RegisterType((*ActionLiquidityTournamentVoteView_Visible)(nil), "penumbra.core.component.funding.v1.ActionLiquidityTournamentVoteView.Visible")
	proto.RegisterType((*ActionLiquidityTournamentVoteView_Opaque)(nil), "penumbra.core.component.funding.v1.ActionLiquidityTournamentVoteView.Opaque")
	proto.RegisterType((*EventLqtDelegatorReward)(nil), "penumbra.core.component.funding.v1.EventLqtDelegatorReward")
	proto.RegisterType((*EventLqtPositionReward)(nil), "penumbra.core.component.funding.v1.EventLqtPositionReward")
	proto.RegisterType((*EventLqtVote)(nil), "penumbra.core.component.funding.v1.EventLqtVote")
}

func init() {
	proto.RegisterFile("penumbra/core/component/funding/v1/funding.proto", fileDescriptor_586f7399b4e8a469)
}

var fileDescriptor_586f7399b4e8a469 = []byte{
	// 1530 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0x1b, 0x37,
	0x16, 0xb7, 0x64, 0xd9, 0x4e, 0x28, 0xc5, 0x6b, 0x33, 0xc9, 0x46, 0x71, 0x12, 0x25, 0x3b, 0xbb,
	0x09, 0xbc, 0x7b, 0x18, 0x45, 0x4e, 0x36, 0x59, 0x38, 0x59, 0x04, 0xb6, 0x13, 0x27, 0x5e, 0x3b,
	0x1b, 0x61, 0xec, 0x0a, 0x41, 0x60, 0x60, 0x40, 0x6b, 0x68, 0x8b, 0xb0, 0x44, 0x8e, 0x49, 0xce,
	0x44, 0x0a, 0x7a, 0xec, 0x07, 0x08, 0x7a, 0x2c, 0x0a, 0x04, 0x68, 0x2f, 0x45, 0x7b, 0xe9, 0xc7,
	0x28, 0x7a, 0x4a, 0x0e, 0x05, 0x72, 0x2c, 0x1c, 0xf4, 0xd2, 0x4f, 0x51, 0x90, 0xc3, 0x19, 0xfd,
	0xb1, 0x65, 0x29, 0x4e, 0x5a, 0xf4, 0x62, 0x73, 0x1e, 0x7f, 0xbf, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
	0x49, 0x81, 0xeb, 0x3e, 0xa6, 0x41, 0x63, 0x8b, 0xa3, 0x62, 0x95, 0x71, 0x5c, 0xac, 0xb2, 0x86,
	0xcf, 0x28, 0xa6, 0xb2, 0xb8, 0x1d, 0x50, 0x8f, 0xd0, 0x9d, 0x62, 0x58, 0x8a, 0x9b, 0xb6, 0xcf,
	0x99, 0x64, 0xd0, 0x8a, 0x19, 0xb6, 0x62, 0xd8, 0x09, 0xc3, 0x8e, 0x61, 0x61, 0x69, 0xc6, 0xea,
	0x56, 0x45, 0x42, 0x60, 0xa9, 0x94, 0x74, 0x23, 0xd2, 0x99, 0x99, 0xed, 0x37, 0xb2, 0x87, 0x9b,
	0x0a, 0xeb, 0xe1, 0xe6, 0x20, 0xa4, 0xa8, 0x6a, 0x55, 0x51, 0x8d, 0x35, 0xef, 0xf6, 0x45, 0xd6,
	0x08, 0xae, 0x7b, 0xd8, 0x73, 0x7d, 0xc6, 0xea, 0x9a, 0xd3, 0x69, 0x30, 0xec, 0x2b, 0xdd, 0xec,
	0x5d, 0xdc, 0x12, 0x0a, 0xaa, 0xfe, 0x1b, 0x44, 0xa1, 0x1b, 0x41, 0x83, 0x86, 0x02, 0xd0, 0xa0,
	0x61, 0xfa, 0xff, 0xd1, 0xdd, 0x2f, 0x9b, 0x35, 0x24, 0x6a, 0x0a, 0x12, 0xb5, 0x0c, 0xea, 0x66,
	0x1b, 0xc5, 0x5b, 0xbe, 0x64, 0x45, 0x0f, 0x57, 0xd1, 0xf6, 0x8d, 0xdb, 0xb7, 0x5d, 0xee, 0x09,
	0x14, 0xcd, 0xbd, 0xc3, 0x10, 0xb1, 0xac, 0xcf, 0x52, 0x20, 0xbf, 0xb6, 0x27, 0x97, 0x6a, 0xb8,
	0xba, 0xfb, 0xff, 0xa0, 0x5e, 0x27, 0xdb, 0x04, 0x73, 0x07, 0xef, 0x05, 0x58, 0x48, 0x78, 0x19,
	0x64, 0xb1, 0xcf, 0xaa, 0x35, 0x97, 0x50, 0x0f, 0x37, 0xf3, 0xa9, 0x2b, 0xa9, 0xd9, 0x8c, 0x03,
	0xb4, 0x69, 0x45, 0x59, 0xe0, 0x43, 0x70, 0x92, 0xc6, 0xa4, 0x7c, 0xfa, 0x4a, 0x6a, 0x36, 0x3b,
	0xf7, 0x4f, 0xbb, 0xdf, 0x4a, 0xaa, 0x80, 0x86, 0x25, 0xbb, 0x3d, 0x4a, 0x9b, 0x6b, 0x7d, 0x97,
	0x02, 0xe7, 0x0f, 0x71, 0x43, 0xf8, 0x8c, 0x0a, 0x0c, 0x1f, 0x81, 0xac, 0xe4, 0x88, 0x0a, 0x54,
	0x95, 0x84, 0x51, 0xed, 0x47, 0x76, 0xee, 0x5a, 0xcf, 0x40, 0x26, 0x18, 0x61, 0xc9, 0xde, 0x68,
	0x63, 0x57, 0x3c, 0xa7, 0x93, 0x0a, 0xff, 0x0e, 0x4e, 0xa1, 0x3a, 0xc7, 0xc8, 0x6b, 0xb9, 0x21,
	0x93, 0xd8, 0xd3, 0x4e, 0x9f, 0x70, 0x72, 0xc6, 0x58, 0x51, 0xb6, 0xde, 0x69, 0x8f, 0xf6, 0x4e,
	0xdb, 0xfa, 0x25, 0x0d, 0xa6, 0x97, 0xa3, 0xbc, 0x2c, 0x23, 0x8e, 0x1a, 0x58, 0x62, 0x2e, 0xe0,
	0xa7, 0xe0, 0x4c, 0x9d, 0xec, 0x05, 0xc4, 0x23, 0xb2, 0xe5, 0x4a, 0x16, 0x70, 0x8a, 0x1a, 0x98,
	0x4a, 0xe3, 0xee, 0x8a, 0x3d, 0x38, 0xc3, 0xed, 0x03, 0xa2, 0xf6, 0x5a, 0xac, 0xb8, 0x91, 0x08,
	0x3a, 0xa7, 0xeb, 0x07, 0x8d, 0x33, 0x6f, 0x52, 0xe0, 0xf4, 0x21, 0x60, 0x78, 0x0b, 0x9c, 0xdb,
	0x41, 0xc1, 0x0e, 0x76, 0x65, 0x8d, 0x63, 0x51, 0x63, 0x75, 0xcf, 0xf5, 0x31, 0xaf, 0xc6, 0x8e,
	0x65, 0x9c, 0xb3, 0xba, 0x7b, 0x23, 0xee, 0x2d, 0x47, 0x9d, 0x2a, 0x52, 0x0d, 0xd4, 0x74, 0x7d,
	0x26, 0x88, 0x8a, 0x9c, 0xd0, 0x91, 0xca, 0x38, 0xb9, 0x06, 0x6a, 0x96, 0x63, 0x1b, 0xbc, 0x0a,
	0x26, 0x15, 0xc8, 0xc3, 0x75, 0xbc, 0x83, 0x24, 0xe3, 0xc2, 0x04, 0x4b, 0x51, 0xef, 0x27, 0x46,
	0xe5, 0x43, 0x02, 0x71, 0x45, 0x0d, 0x71, 0x9c, 0xf8, 0x90, 0x89, 0x7c, 0x48, 0xba, 0xd7, 0x55,
	0xaf, 0xf1, 0xc1, 0xa2, 0x60, 0xf2, 0x21, 0xa6, 0x58, 0x10, 0xb1, 0xc4, 0xa8, 0x54, 0x5e, 0x6d,
	0x82, 0x49, 0x13, 0x2e, 0xd7, 0x57, 0x41, 0x12, 0x26, 0xba, 0xff, 0x3e, 0x56, 0x74, 0x9d, 0x53,
	0xdb, 0x1d, 0x26, 0x61, 0x7d, 0x99, 0x02, 0xf9, 0x07, 0x21, 0xa6, 0xd2, 0x20, 0xd7, 0x25, 0xc7,
	0xa8, 0xe1, 0xe0, 0xe7, 0x88, 0x7b, 0xf0, 0x22, 0x38, 0xc9, 0x71, 0x95, 0xf8, 0x24, 0x0e, 0xdd,
	0x49, 0xa7, 0x6d, 0xe8, 0xcd, 0x99, 0xf4, 0x81, 0xad, 0xb2, 0x00, 0x4e, 0x71, 0x2d, 0xe4, 0xa2,
	0x06, 0x0b, 0xa8, 0xd4, 0x91, 0xca, 0xce, 0x5d, 0xec, 0x71, 0x5c, 0xed, 0xfa, 0xb0, 0x64, 0x2f,
	0x68, 0x8c, 0x93, 0x8b, 0x28, 0xd1, 0x97, 0xf5, 0x2a, 0x0d, 0x2e, 0x2d, 0xe8, 0x3c, 0x3e, 0x64,
	0xa1, 0x55, 0xea, 0xc2, 0x75, 0x90, 0xd9, 0x62, 0x5e, 0xcb, 0x04, 0xe5, 0xde, 0x30, 0x41, 0xe9,
	0x23, 0xb5, 0xc8, 0xbc, 0x96, 0xa3, 0xc5, 0xe0, 0x13, 0x70, 0x02, 0x05, 0xb2, 0xe6, 0x0a, 0xb2,
	0x63, 0xf6, 0xf8, 0xcd, 0x0e, 0x61, 0x5d, 0x6b, 0xec, 0xee, 0xd2, 0x12, 0x96, 0xec, 0x75, 0x1f,
	0x53, 0x6f, 0x21, 0x90, 0xb5, 0x75, 0xb2, 0x43, 0x91, 0x0c, 0x38, 0x76, 0x26, 0x50, 0xf4, 0x09,
	0x9f, 0x82, 0x31, 0x9f, 0x33, 0xb6, 0x6d, 0x42, 0xb0, 0x38, 0x8c, 0x9b, 0xcf, 0x56, 0xfb, 0x38,
	0x5a, 0x56, 0x4a, 0x4e, 0x24, 0x68, 0x7d, 0x31, 0x0a, 0x2e, 0x1c, 0x31, 0x21, 0xb8, 0x00, 0x72,
	0x84, 0xaa, 0xd4, 0x22, 0x21, 0x79, 0x81, 0x3d, 0x13, 0xa7, 0x4b, 0x3d, 0x0e, 0x44, 0xe7, 0x49,
	0x58, 0xb2, 0xef, 0x63, 0xca, 0x1a, 0x4e, 0x17, 0x05, 0xae, 0x82, 0xe9, 0x68, 0x51, 0x84, 0xdb,
	0x4e, 0x87, 0x28, 0x2c, 0x85, 0x1e, 0x1d, 0x5d, 0xe2, 0xd5, 0x62, 0x7a, 0x1e, 0xc7, 0x42, 0x38,
	0x53, 0x86, 0xe8, 0x24, 0x59, 0x73, 0x15, 0x4c, 0x0a, 0x89, 0xb8, 0x4c, 0xb6, 0x59, 0xbc, 0x7f,
	0xb4, 0x35, 0xde, 0x67, 0xf0, 0x06, 0x18, 0x0b, 0x51, 0x3d, 0xc0, 0x7a, 0xb7, 0x1c, 0xe1, 0x6f,
	0x45, 0x81, 0x9c, 0x08, 0xdb, 0x5d, 0x9b, 0xc7, 0x8e, 0x5f, 0x9b, 0xe1, 0x32, 0x48, 0xf3, 0xdd,
	0xfc, 0xb8, 0x56, 0xb8, 0x35, 0xe4, 0xca, 0x57, 0x30, 0x27, 0xdb, 0xa4, 0x8a, 0x94, 0xfb, 0xab,
	0xb8, 0xe5, 0xa4, 0xf9, 0xae, 0xf5, 0x66, 0x14, 0xfc, 0xed, 0xc8, 0xf4, 0x2d, 0xd7, 0x11, 0xfd,
	0xd3, 0x2d, 0xd1, 0x13, 0x90, 0x15, 0x12, 0xed, 0x62, 0xcf, 0xa5, 0x4c, 0x62, 0x93, 0xb2, 0x76,
	0xff, 0x40, 0x76, 0xdd, 0x00, 0x54, 0x48, 0x99, 0xc4, 0x0e, 0x88, 0x24, 0x54, 0x1b, 0x5e, 0x07,
	0x67, 0x3a, 0x04, 0xdb, 0x2b, 0x1f, 0x55, 0x42, 0xd8, 0x46, 0x26, 0xcb, 0x7f, 0x30, 0x4b, 0xc6,
	0x0e, 0xcb, 0x92, 0x02, 0x00, 0x1c, 0x51, 0x8f, 0x35, 0xc8, 0x0b, 0xcc, 0xf5, 0x7a, 0xe5, 0x9c,
	0x0e, 0x0b, 0x9c, 0x05, 0x53, 0x7a, 0x97, 0xb8, 0x5b, 0x75, 0x12, 0x95, 0x50, 0x9e, 0x9f, 0xd0,
	0xa8, 0x49, 0x6d, 0x5f, 0x34, 0x66, 0xe7, 0x10, 0xa4, 0xc8, 0x9f, 0x38, 0x04, 0xb9, 0x6e, 0xdd,
	0x02, 0x85, 0xa3, 0x77, 0x26, 0x3c, 0x03, 0xc6, 0x08, 0xa5, 0x98, 0xeb, 0x85, 0xcc, 0x39, 0xd1,
	0x87, 0xf5, 0x2a, 0x33, 0x20, 0x17, 0x2a, 0x04, 0x3f, 0x87, 0x04, 0x4c, 0x84, 0x44, 0x90, 0xad,
	0x3a, 0x36, 0x69, 0xf0, 0x78, 0x98, 0x52, 0x31, 0x50, 0xd7, 0xae, 0x44, 0xa2, 0x8f, 0x46, 0x9c,
	0x58, 0x1f, 0x6e, 0x83, 0x71, 0xe6, 0xa3, 0xbd, 0x00, 0x9b, 0x44, 0x59, 0xfb, 0x38, 0x23, 0x3d,
	0xd1, 0x9a, 0x8f, 0x46, 0x1c, 0xa3, 0x3e, 0xf3, 0x4d, 0x0a, 0x4c, 0x98, 0xe1, 0xe1, 0x27, 0x20,
	0xa3, 0x2e, 0x21, 0x66, 0x6e, 0x0b, 0x1f, 0x3c, 0xa2, 0xa3, 0xe5, 0xe0, 0x32, 0xc8, 0xe8, 0x54,
	0x8d, 0x26, 0x32, 0xf7, 0x7e, 0xa9, 0xaa, 0xbc, 0x76, 0x34, 0x7f, 0xc6, 0x05, 0xe3, 0x91, 0xfb,
	0xbf, 0x93, 0xa3, 0x8b, 0x17, 0xc0, 0xf9, 0xc3, 0x2e, 0x4c, 0xfa, 0x66, 0x66, 0xbd, 0x4d, 0x83,
	0x73, 0xfa, 0x2c, 0x5e, 0xdb, 0x93, 0xc9, 0x55, 0xc2, 0x1c, 0xc5, 0x03, 0xef, 0xa5, 0x07, 0x0e,
	0xdb, 0xf4, 0xfb, 0x1e, 0xb6, 0xf0, 0x7f, 0x60, 0xda, 0x5c, 0x4a, 0x08, 0xa3, 0xae, 0x64, 0xbb,
	0x98, 0x0a, 0xb3, 0xfb, 0x07, 0xd4, 0xdf, 0xa9, 0x36, 0x6f, 0x43, 0xd3, 0xe0, 0x7f, 0xc0, 0x04,
	0x8a, 0x0a, 0x8c, 0xa9, 0xe0, 0x83, 0xca, 0x50, 0x0c, 0x87, 0xeb, 0xe0, 0x6c, 0x67, 0x69, 0x73,
	0xf5, 0x50, 0x2e, 0xf1, 0x4c, 0x41, 0xbf, 0xdc, 0xcf, 0x93, 0x05, 0xd5, 0x58, 0xf1, 0x9c, 0xd3,
	0x9d, 0x6c, 0x63, 0xb4, 0xbe, 0x1f, 0x05, 0x7f, 0x8d, 0x43, 0x1b, 0x57, 0x8f, 0x3f, 0x30, 0xb2,
	0xab, 0x20, 0x1b, 0x17, 0x32, 0x35, 0x93, 0x28, 0xa6, 0xff, 0xea, 0x9b, 0x54, 0xea, 0xc5, 0x16,
	0x96, 0xec, 0xd8, 0xd1, 0x15, 0xcf, 0x01, 0x7e, 0xd2, 0xee, 0x1f, 0xa0, 0xcc, 0xf1, 0x03, 0x04,
	0x57, 0xc0, 0x74, 0x57, 0x3a, 0xd6, 0x83, 0x06, 0xce, 0x83, 0x21, 0x26, 0x3a, 0x25, 0x3b, 0xf2,
	0x5c, 0xb1, 0xe0, 0x03, 0xf0, 0x97, 0x64, 0xb2, 0x46, 0x28, 0x3b, 0x84, 0xd0, 0x64, 0x4c, 0x8a,
	0x64, 0xac, 0xcf, 0x47, 0x41, 0x2e, 0x5e, 0x32, 0x7d, 0xd3, 0x1b, 0xb8, 0x50, 0xf7, 0x40, 0x2e,
	0x64, 0x52, 0x5f, 0x94, 0xd9, 0xf3, 0xe4, 0x75, 0x76, 0xf4, 0xa8, 0xd9, 0x88, 0x51, 0x56, 0x84,
	0xfe, 0x91, 0x1d, 0xfd, 0x80, 0xc8, 0xf6, 0x9e, 0xee, 0x99, 0x8f, 0x74, 0xba, 0x8f, 0x1d, 0xf3,
	0x74, 0xbf, 0x03, 0xc6, 0x64, 0x53, 0x4d, 0x6a, 0xfc, 0xbd, 0xde, 0x94, 0x19, 0xd9, 0x5c, 0xf1,
	0xe6, 0xbe, 0x4e, 0x81, 0xc9, 0xf8, 0xa5, 0x80, 0x79, 0x48, 0xaa, 0x18, 0xbe, 0x4c, 0x81, 0xe9,
	0x03, 0xef, 0x58, 0x78, 0x77, 0xa8, 0x8b, 0x78, 0x9f, 0x57, 0xf8, 0xcc, 0x7f, 0x8f, 0xc9, 0x8e,
	0x1e, 0xcf, 0x8b, 0x3f, 0xa5, 0x7f, 0xd8, 0x2f, 0xa4, 0x5e, 0xef, 0x17, 0x52, 0x3f, 0xef, 0x17,
	0x52, 0x2f, 0xdf, 0x15, 0x46, 0x5e, 0xbf, 0x2b, 0x8c, 0xbc, 0x7d, 0x57, 0x18, 0x01, 0xd7, 0xaa,
	0xac, 0x31, 0x84, 0xf8, 0x62, 0x2e, 0x7e, 0x39, 0x71, 0x26, 0x59, 0x39, 0xf5, 0xec, 0xe9, 0x0e,
	0x91, 0xb5, 0x60, 0x4b, 0x81, 0x8b, 0x55, 0x26, 0x1a, 0x4c, 0x14, 0x39, 0xae, 0xa3, 0x16, 0xe6,
	0xc5, 0x70, 0x2e, 0x69, 0x56, 0x6b, 0x88, 0x50, 0x51, 0x1c, 0xfc, 0x53, 0xd0, 0x1d, 0xd3, 0x0c,
	0x4b, 0x5f, 0xa5, 0x33, 0xe5, 0xa5, 0xa5, 0xe5, 0x6f, 0xd3, 0x56, 0x39, 0xf6, 0x6a, 0x49, 0x79,
	0xb5, 0x94, 0x78, 0x65, 0x3c, 0xb1, 0x2b, 0xa5, 0x1f, 0xdb, 0xa0, 0x4d, 0x05, 0xda, 0x4c, 0x40,
	0x9b, 0x06, 0xb4, 0x59, 0x29, 0xed, 0xa7, 0xed, 0xc1, 0xa0, 0xcd, 0x87, 0xe5, 0xc5, 0xc7, 0x58,
	0x22, 0x0f, 0x49, 0xf4, 0x6b, 0xfa, 0x5a, 0x4c, 0x98, 0x9f, 0x57, 0x0c, 0xf5, 0xd7, 0x50, 0xe6,
	0xe7, 0x0d, 0x67, 0x7e, 0xbe, 0x52, 0xda, 0x1a, 0xd7, 0x3f, 0xa0, 0xdc, 0xf8, 0x2d, 0x00, 0x00,
	0xff, 0xff, 0x72, 0x30, 0x50, 0xee, 0xec, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FundingServiceClient is the client API for FundingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FundingServiceClient interface {
	// Checks if a particular nullifier has already been used in the current epoch.
	LqtCheckNullifier(ctx context.Context, in *LqtCheckNullifierRequest, opts ...grpc.CallOption) (*LqtCheckNullifierResponse, error)
}

type fundingServiceClient struct {
	cc grpc1.ClientConn
}

func NewFundingServiceClient(cc grpc1.ClientConn) FundingServiceClient {
	return &fundingServiceClient{cc}
}

func (c *fundingServiceClient) LqtCheckNullifier(ctx context.Context, in *LqtCheckNullifierRequest, opts ...grpc.CallOption) (*LqtCheckNullifierResponse, error) {
	out := new(LqtCheckNullifierResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.funding.v1.FundingService/LqtCheckNullifier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FundingServiceServer is the server API for FundingService service.
type FundingServiceServer interface {
	// Checks if a particular nullifier has already been used in the current epoch.
	LqtCheckNullifier(context.Context, *LqtCheckNullifierRequest) (*LqtCheckNullifierResponse, error)
}

// UnimplementedFundingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFundingServiceServer struct {
}

func (*UnimplementedFundingServiceServer) LqtCheckNullifier(ctx context.Context, req *LqtCheckNullifierRequest) (*LqtCheckNullifierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LqtCheckNullifier not implemented")
}

func RegisterFundingServiceServer(s grpc1.Server, srv FundingServiceServer) {
	s.RegisterService(&_FundingService_serviceDesc, srv)
}

func _FundingService_LqtCheckNullifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LqtCheckNullifierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundingServiceServer).LqtCheckNullifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.funding.v1.FundingService/LqtCheckNullifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundingServiceServer).LqtCheckNullifier(ctx, req.(*LqtCheckNullifierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FundingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.funding.v1.FundingService",
	HandlerType: (*FundingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LqtCheckNullifier",
			Handler:    _FundingService_LqtCheckNullifier_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/core/component/funding/v1/funding.proto",
}

func (m *LqtCheckNullifierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LqtCheckNullifierRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LqtCheckNullifierRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LqtCheckNullifierResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LqtCheckNullifierResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LqtCheckNullifierResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.AlreadyVoted {
		i--
		if m.AlreadyVoted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundingParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiquidityTournament != nil {
		{
			size, err := m.LiquidityTournament.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundingParameters_LiquidityTournament) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingParameters_LiquidityTournament) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingParameters_LiquidityTournament) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorSharePercent != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.DelegatorSharePercent))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDelegators != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.MaxDelegators))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPositions != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.MaxPositions))
		i--
		dAtA[i] = 0x10
	}
	if m.GaugeThresholdPercent != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.GaugeThresholdPercent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FundingParams != nil {
		{
			size, err := m.FundingParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFundingStreamReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFundingStreamReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFundingStreamReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardAmount != nil {
		{
			size, err := m.RewardAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintFunding(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionLiquidityTournamentVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLiquidityTournamentVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTournamentVoteBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTournamentVoteBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTournamentVoteBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rk != nil {
		{
			size, err := m.Rk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartPosition != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x18
	}
	if m.RewardsRecipient != nil {
		{
			size, err := m.RewardsRecipient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Incentivized != nil {
		{
			size, err := m.Incentivized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionLiquidityTournamentVotePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLiquidityTournamentVotePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVotePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintFunding(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintFunding(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintFunding(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x32
	}
	if m.StartPosition != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x28
	}
	if m.StakedNotePosition != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.StakedNotePosition))
		i--
		dAtA[i] = 0x20
	}
	if m.StakedNote != nil {
		{
			size, err := m.StakedNote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RewardsRecipient != nil {
		{
			size, err := m.RewardsRecipient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Incentivized != nil {
		{
			size, err := m.Incentivized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKLiquidityTournamentVoteProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKLiquidityTournamentVoteProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKLiquidityTournamentVoteProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintFunding(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionLiquidityTournamentVoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLiquidityTournamentVoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiquidityTournamentVote != nil {
		{
			size := m.LiquidityTournamentVote.Size()
			i -= size
			if _, err := m.LiquidityTournamentVote.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionLiquidityTournamentVoteView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVoteView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionLiquidityTournamentVoteView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVoteView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionLiquidityTournamentVoteView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLiquidityTournamentVoteView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVoteView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionLiquidityTournamentVoteView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLiquidityTournamentVoteView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionLiquidityTournamentVoteView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventLqtDelegatorReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLqtDelegatorReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLqtDelegatorReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncentivizedAssetId != nil {
		{
			size, err := m.IncentivizedAssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DelegationTokens != nil {
		{
			size, err := m.DelegationTokens.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RewardAmount != nil {
		{
			size, err := m.RewardAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventLqtPositionReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLqtPositionReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLqtPositionReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionVolume != nil {
		{
			size, err := m.PositionVolume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.TournamentVolume != nil {
		{
			size, err := m.TournamentVolume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IncentivizedAssetId != nil {
		{
			size, err := m.IncentivizedAssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RewardAmount != nil {
		{
			size, err := m.RewardAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventLqtVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLqtVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLqtVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxId != nil {
		{
			size, err := m.TxId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RewardsRecipient != nil {
		{
			size, err := m.RewardsRecipient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Incentivized != nil {
		{
			size, err := m.Incentivized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IncentivizedAssetId != nil {
		{
			size, err := m.IncentivizedAssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.VotingPower != nil {
		{
			size, err := m.VotingPower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunding(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EpochIndex != 0 {
		i = encodeVarintFunding(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFunding(dAtA []byte, offset int, v uint64) int {
	offset -= sovFunding(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LqtCheckNullifierRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *LqtCheckNullifierResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.AlreadyVoted {
		n += 2
	}
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	return n
}

func (m *FundingParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidityTournament != nil {
		l = m.LiquidityTournament.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *FundingParameters_LiquidityTournament) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GaugeThresholdPercent != 0 {
		n += 1 + sovFunding(uint64(m.GaugeThresholdPercent))
	}
	if m.MaxPositions != 0 {
		n += 1 + sovFunding(uint64(m.MaxPositions))
	}
	if m.MaxDelegators != 0 {
		n += 1 + sovFunding(uint64(m.MaxDelegators))
	}
	if m.DelegatorSharePercent != 0 {
		n += 1 + sovFunding(uint64(m.DelegatorSharePercent))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FundingParams != nil {
		l = m.FundingParams.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *EventFundingStreamReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	if m.RewardAmount != nil {
		l = m.RewardAmount.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *ActionLiquidityTournamentVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *LiquidityTournamentVoteBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Incentivized != nil {
		l = m.Incentivized.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.RewardsRecipient != nil {
		l = m.RewardsRecipient.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.StartPosition != 0 {
		n += 1 + sovFunding(uint64(m.StartPosition))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Rk != nil {
		l = m.Rk.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *ActionLiquidityTournamentVotePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Incentivized != nil {
		l = m.Incentivized.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.RewardsRecipient != nil {
		l = m.RewardsRecipient.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.StakedNote != nil {
		l = m.StakedNote.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.StakedNotePosition != 0 {
		n += 1 + sovFunding(uint64(m.StakedNotePosition))
	}
	if m.StartPosition != 0 {
		n += 1 + sovFunding(uint64(m.StartPosition))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovFunding(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovFunding(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *ZKLiquidityTournamentVoteProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *ActionLiquidityTournamentVoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidityTournamentVote != nil {
		n += m.LiquidityTournamentVote.Size()
	}
	return n
}

func (m *ActionLiquidityTournamentVoteView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}
func (m *ActionLiquidityTournamentVoteView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}
func (m *ActionLiquidityTournamentVoteView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *ActionLiquidityTournamentVoteView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *EventLqtDelegatorReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	if m.RewardAmount != nil {
		l = m.RewardAmount.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.DelegationTokens != nil {
		l = m.DelegationTokens.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.IncentivizedAssetId != nil {
		l = m.IncentivizedAssetId.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *EventLqtPositionReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	if m.RewardAmount != nil {
		l = m.RewardAmount.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.IncentivizedAssetId != nil {
		l = m.IncentivizedAssetId.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.TournamentVolume != nil {
		l = m.TournamentVolume.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.PositionVolume != nil {
		l = m.PositionVolume.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func (m *EventLqtVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovFunding(uint64(m.EpochIndex))
	}
	if m.VotingPower != nil {
		l = m.VotingPower.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.IncentivizedAssetId != nil {
		l = m.IncentivizedAssetId.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.Incentivized != nil {
		l = m.Incentivized.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.RewardsRecipient != nil {
		l = m.RewardsRecipient.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	if m.TxId != nil {
		l = m.TxId.Size()
		n += 1 + l + sovFunding(uint64(l))
	}
	return n
}

func sovFunding(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFunding(x uint64) (n int) {
	return sovFunding(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LqtCheckNullifierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LqtCheckNullifierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LqtCheckNullifierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LqtCheckNullifierResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LqtCheckNullifierResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LqtCheckNullifierResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &v11.TransactionId{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlreadyVoted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlreadyVoted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTournament", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LiquidityTournament == nil {
				m.LiquidityTournament = &FundingParameters_LiquidityTournament{}
			}
			if err := m.LiquidityTournament.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingParameters_LiquidityTournament) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTournament: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTournament: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GaugeThresholdPercent", wireType)
			}
			m.GaugeThresholdPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GaugeThresholdPercent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPositions", wireType)
			}
			m.MaxPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDelegators", wireType)
			}
			m.MaxDelegators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDelegators |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSharePercent", wireType)
			}
			m.DelegatorSharePercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelegatorSharePercent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FundingParams == nil {
				m.FundingParams = &FundingParameters{}
			}
			if err := m.FundingParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFundingStreamReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFundingStreamReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFundingStreamReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardAmount == nil {
				m.RewardAmount = &v12.Amount{}
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLiquidityTournamentVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &LiquidityTournamentVoteBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v13.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKLiquidityTournamentVoteProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTournamentVoteBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTournamentVoteBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTournamentVoteBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incentivized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Incentivized == nil {
				m.Incentivized = &v14.Denom{}
			}
			if err := m.Incentivized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsRecipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsRecipient == nil {
				m.RewardsRecipient = &v15.Address{}
			}
			if err := m.RewardsRecipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v14.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rk == nil {
				m.Rk = &v13.SpendVerificationKey{}
			}
			if err := m.Rk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLiquidityTournamentVotePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVotePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVotePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incentivized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Incentivized == nil {
				m.Incentivized = &v14.Denom{}
			}
			if err := m.Incentivized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsRecipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsRecipient == nil {
				m.RewardsRecipient = &v15.Address{}
			}
			if err := m.RewardsRecipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakedNote == nil {
				m.StakedNote = &v16.Note{}
			}
			if err := m.StakedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNotePosition", wireType)
			}
			m.StakedNotePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakedNotePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKLiquidityTournamentVoteProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKLiquidityTournamentVoteProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKLiquidityTournamentVoteProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLiquidityTournamentVoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLiquidityTournamentVoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionLiquidityTournamentVoteView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LiquidityTournamentVote = &ActionLiquidityTournamentVoteView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionLiquidityTournamentVoteView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LiquidityTournamentVote = &ActionLiquidityTournamentVoteView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLiquidityTournamentVoteView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &ActionLiquidityTournamentVote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v16.NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLiquidityTournamentVoteView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &ActionLiquidityTournamentVote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLqtDelegatorReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLqtDelegatorReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLqtDelegatorReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardAmount == nil {
				m.RewardAmount = &v12.Amount{}
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegationTokens == nil {
				m.DelegationTokens = &v14.Value{}
			}
			if err := m.DelegationTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v15.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivizedAssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncentivizedAssetId == nil {
				m.IncentivizedAssetId = &v14.AssetId{}
			}
			if err := m.IncentivizedAssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLqtPositionReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLqtPositionReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLqtPositionReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardAmount == nil {
				m.RewardAmount = &v12.Amount{}
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &v17.PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivizedAssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncentivizedAssetId == nil {
				m.IncentivizedAssetId = &v14.AssetId{}
			}
			if err := m.IncentivizedAssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TournamentVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TournamentVolume == nil {
				m.TournamentVolume = &v12.Amount{}
			}
			if err := m.TournamentVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionVolume == nil {
				m.PositionVolume = &v12.Amount{}
			}
			if err := m.PositionVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLqtVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLqtVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLqtVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotingPower == nil {
				m.VotingPower = &v12.Amount{}
			}
			if err := m.VotingPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivizedAssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncentivizedAssetId == nil {
				m.IncentivizedAssetId = &v14.AssetId{}
			}
			if err := m.IncentivizedAssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incentivized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Incentivized == nil {
				m.Incentivized = &v14.Denom{}
			}
			if err := m.Incentivized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsRecipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsRecipient == nil {
				m.RewardsRecipient = &v15.Address{}
			}
			if err := m.RewardsRecipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunding
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunding
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxId == nil {
				m.TxId = &v11.TransactionId{}
			}
			if err := m.TxId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFunding(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFunding
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFunding
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFunding
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFunding
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFunding        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFunding          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFunding = fmt.Errorf("proto: unexpected end of group")
)
